<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Primary Meta Tags -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Heart-Touching Game: Crush Quest | Collect Hearts & Avoid Enemies | Aarif Alam</title>
  <meta name="description" content="Play the heart-touching Crush Quest game - collect all hearts while avoiding black enemies. Challenging levels with increasing difficulty. Perfect for kids and adults to test reflexes!">
  <meta name="keywords" content="heart touching game, crush quest, collect hearts game, online puzzle game, reflex game, family game, educational game, Aarif Alam">
  <meta name="author" content="Aarif Alam">
  
  <!-- Canonical URL -->
  <link rel="canonical" href="https://aarifalam.life/Game/Heart-Touch-game.html">
  
  <!-- Favicon -->
  <link rel="icon" href="https://aarifalam.life/favicon.ico" type="image/x-icon">
  
  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="Heart-Touching Game: Crush Quest | Collect Hearts & Avoid Enemies">
  <meta property="og:description" content="Play the heart-touching Crush Quest game - collect all hearts while avoiding black enemies. Challenging levels with increasing difficulty.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://aarifalam.life/games/Heart-Touch-game.html">
  <meta property="og:image" content="https://res.cloudinary.com/dcwnn9c0u/image/upload/v1747539320/heart-touch_s9vg6y.png">
  <meta property="og:image:alt" content="Heart-Touching Crush Quest Game Screenshot">
  <meta property="og:site_name" content="Aarif Alam">
  
  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Heart-Touching Game: Crush Quest | Collect Hearts & Avoid Enemies">
  <meta name="twitter:description" content="Play the heart-touching Crush Quest game - collect all hearts while avoiding black enemies. Challenging levels with increasing difficulty.">
  <meta name="twitter:image" content="https://res.cloudinary.com/dcwnn9c0u/image/upload/v1747539320/heart-touch_s9vg6y.png">
  <meta name="twitter:site" content="@AarifAlam0105">
  <meta name="twitter:creator" content="@AarifAlam0105">
  
  <!-- Structured Data / Schema Markup -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Crush Quest - Heart Touching Game",
      "url": "https://aarifalam.life/games/Heart-Touch-game.html",
      "description": "A fun and challenging game where players collect hearts while avoiding black enemies",
      "applicationCategory": "Game",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "creator": {
        "@type": "Person",
        "name": "Aarif Alam"
      },
      "screenshot": "https://res.cloudinary.com/dcwnn9c0u/image/upload/v1747539320/heart-touch_s9vg6y.png",
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "500"
      }
    }
  </script>
  
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "name": "Aarif Alam",
        "item": "https://aarifalam.life"
      },{
        "@type": "ListItem",
        "position": 2,
        "name": "Games",
        "item": "https://aarifalam.life/games"
      },{
        "@type": "ListItem",
        "position": 3,
        "name": "Crush Quest",
        "item": "https://aarifalam.life/games/Heart-Touch-game.html"
      }]
    }
  </script>

  <!-- Preload important resources -->
  <link rel="preload" href="https://res.cloudinary.com/dcwnn9c0u/image/upload/v1747539320/heart-touch_s9vg6y.png" as="image">
  <link rel="preconnect" href="https://res.cloudinary.com">



  <style>
    body {
      margin: 0;
      font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
      overflow: hidden;
      touch-action: manipulation;
      background: linear-gradient(-45deg, #ff9a9e, #fad0c4, #fad0c4, #a18cd1);
      background-size: 400% 400%;
      animation: gradientBG 15s ease infinite;
      height: 100vh;
    }

    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 10px;
    }

    canvas {
      display: block;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.8);
      border: 5px solid #ff66a3;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(255, 102, 163, 0.6);
      touch-action: none;
    }

    #scoreBoard {
      text-align: center;
      font-size: 24px;
      margin: 10px 0;
      color: #fff;
      text-shadow: 1px 1px 2px #ff3385;
      background: rgba(255, 51, 133, 0.7);
      padding: 10px 20px;
      border-radius: 20px;
      width: 80%;
      max-width: 400px;
    }

    #levelInfo {
      text-align: center;
      font-size: 20px;
      margin: 5px 0;
      color: #fff;
      text-shadow: 1px 1px 2px #99004d;
    }

    #gameOver, #gameWin, #controls {
      text-align: center;
      margin-top: 20px;
    }

    .btn {
      background-color: #ff3385;
      color: white;
      border: none;
      padding: 12px 25px;
      font-size: 18px;
      margin: 8px;
      border-radius: 30px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.3s;
      font-weight: bold;
    }

    .btn:hover {
      background-color: #cc0059;
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }

    .btn:active {
      transform: translateY(1px);
    }

    #touchControls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 15px;
      width: 100%;
      max-width: 400px;
    }

    .touch-btn {
      width: 70px;
      height: 70px;
      margin: 8px;
      background: rgba(255, 102, 163, 0.8);
      color: white;
      font-size: 28px;
      text-align: center;
      line-height: 70px;
      border-radius: 20px;
      user-select: none;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.2s;
    }

    .touch-btn:active {
      transform: scale(0.95);
      background: rgba(255, 51, 133, 0.9);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background: #fff0f5;
      padding: 30px;
      border-radius: 20px;
      max-width: 90%;
      width: 400px;
      text-align: center;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      border: 3px solid #ff66a3;
    }

    .modal h2 {
      color: #ff3385;
      margin-bottom: 20px;
    }

    .modal p {
      margin-bottom: 20px;
      font-size: 18px;
      color: #333;
    }

    #rewardCode {
      font-size: 24px;
      font-weight: bold;
      color: #ff3385;
      background: #fff;
      padding: 10px;
      border-radius: 5px;
      margin: 15px 0;
      border: 2px dashed #ff66a3;
    }

    #bonusAlert {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 215, 0, 0.9);
      color: #8B4513;
      padding: 15px 25px;
      border-radius: 10px;
      font-weight: bold;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      z-index: 50;
      display: none;
      animation: slideIn 0.5s, fadeOut 0.5s 2.5s forwards;
    }

    @keyframes slideIn {
      from { top: -50px; opacity: 0; }
      to { top: 20px; opacity: 1; }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    .heart {
      position: absolute;
      font-size: 20px;
      animation: float 3s ease-in-out infinite;
      opacity: 0.7;
      z-index: -1;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
    }

    #playerStats {
      display: flex;
      justify-content: space-around;
      width: 100%;
      max-width: 400px;
      margin-bottom: 10px;
    }

    .stat {
      background: rgba(255, 255, 255, 0.8);
      padding: 8px 15px;
      border-radius: 15px;
      font-size: 16px;
      color: #ff3385;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <div id="playerStats">
    <div class="stat">Level: <span id="levelDisplay">1</span></div>
    <div class="stat">Coins: <span id="coinDisplay">0</span></div>
  </div>
  
  <div id="levelInfo">Collect all hearts to advance!</div>
  
  <canvas id="gameCanvas" width="400" height="400"></canvas>
  
  <div id="scoreBoard">
    Hearts: <span id="score">0</span>/<span id="totalHearts">5</span>
  </div>

  <div id="gameOver" style="display: none;">
    <h2>💔 Game Over!</h2>
    <button class="btn" onclick="tryAgain()">Try Again</button>
    <button class="btn" onclick="resetGame()">Reset Game</button>
  </div>

  <div id="controls">
    <button class="btn" onclick="showMenu()">STOP</button>
    <button class="btn" onclick="toggleFullscreen()">⛶ Fullscreen</button>
  </div>

  <!-- Mobile Controls -->
  <div id="touchControls">
    <div class="touch-btn" onclick="move('up')">⬆️</div>
    <div style="width: 100%; display: flex; justify-content: center;">
      <div class="touch-btn" onclick="move('left')">⬅️</div>
      <div class="touch-btn" onclick="move('down')">⬇️</div>
      <div class="touch-btn" onclick="move('right')">➡️</div>
    </div>
  </div>
</div>

<!-- Win Modal -->
<div id="winModal" class="modal">
  <div class="modal-content">
    <h2>🎉 Level Complete! 🎉</h2>
    <p id="winMessage">You collected all the hearts!</p>
    <div id="rewardInfo"></div>
    <button class="btn" onclick="nextLevel()">Next Level</button>
  </div>
</div>

<!-- Final Win Modal -->
<div id="finalWinModal" class="modal">
  <div class="modal-content">
    <h2>🏆 Congratulations! 🏆</h2>
    <p id="finalWinMessage">You've completed level <span id="finalLevelDisplay">10</span>!</p>
    <div id="finalRewardInfo"></div>
    <div id="rewardCodeContainer">
      <p>Your reward code:</p>
      <div id="rewardCode">XXXX-XXXX-XXXX</div>
      <p>Use this code to claim your reward!</p>
    </div>
    <button class="btn" onclick="nextLevel()">Continue</button>
  </div>
</div>

<!-- Bonus Alert -->
<div id="bonusAlert"></div>

<script>
// Game configuration
const config = {
  initialHearts: 4,
  initialBadGuys: 2,
  speedIncrease: 0.2,
  badGuyIncrease: 1,
  heartIncrease: 2,
  coinReward: 100,
  bonusRewards: {
    5:  " <h1>⚡2 SUBSCRIBERS 🔔!", 
    10: "<h1>🫂5 LIKE 👍!",
    15: "<h1>➡️ 5 COMMENT!💬",
    20: "<h1>⚡5 SUBSCRIBERS 🔔!",
    25: " <h1>➡️5 COMMENT!💬                  ",
    30: "<h1> 5⚡ SUBSCRIBERS 🔔!"
  }
};

// [PASTE YOUR 100 UNIQUE CODES HERE]
const rewardCodes = [
  "AARIF-0143-3753", "AABID-0143-1903", "RAHUL-0143-8878","your-surprises-reward",
  // ... add all 100 codes here ...
];

// Game elements
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const scoreText = document.getElementById("score");
const totalHeartsText = document.getElementById("totalHearts");
const levelDisplay = document.getElementById("levelDisplay");
const coinDisplay = document.getElementById("coinDisplay");
const gameOverText = document.getElementById("gameOver");
const winModal = document.getElementById("winModal");
const finalWinModal = document.getElementById("finalWinModal");
const winMessage = document.getElementById("winMessage");
const finalWinMessage = document.getElementById("finalWinMessage");
const finalLevelDisplay = document.getElementById("finalLevelDisplay");
const rewardInfo = document.getElementById("rewardInfo");
const finalRewardInfo = document.getElementById("finalRewardInfo");
const rewardCode = document.getElementById("rewardCode");
const bonusAlert = document.getElementById("bonusAlert");
const touchControls = document.getElementById("touchControls");

let player, hearts, badGuys, coins = 0, score, gameOver, gameLoopId;
let currentLevel = 1;
let usedCodes = [];
let isDragging = false;
let touchOffsetX = 0;
let touchOffsetY = 0;
let heartMoveInterval;
let movingHearts = false;

// Player stats with default values
let playerStats = {
  level: 1,
  coins: 0,
  usedCodes: []
};

// Check if mobile device
function isMobile() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// Load game data from local storage
function loadGame() {
  const savedData = localStorage.getItem('crushQuestData');
  if (savedData) {
    try {
      const data = JSON.parse(savedData);
      currentLevel = data.level || 1;
      coins = data.coins || 0;
      usedCodes = data.usedCodes || [];
      playerStats = data;
      updateStatsDisplay();
    } catch (e) {
      console.error("Error loading saved data:", e);
    }
  }
}

// Save game data to local storage
function saveGame() {
  playerStats.level = currentLevel;
  playerStats.coins = coins;
  playerStats.usedCodes = usedCodes;
  localStorage.setItem('crushQuestData', JSON.stringify(playerStats));
}

// Update stats display
function updateStatsDisplay() {
  levelDisplay.textContent = currentLevel;
  coinDisplay.textContent = coins;
}

// Initialize game
function initGame() {
  touchControls.style.display = isMobile() ? 'flex' : 'none';
  createFloatingHearts();
  loadGame();
  
  player = { 
    x: canvas.width / 2, 
    y: canvas.height - 50, 
    size: 25, 
    color: "#ff3385",
    speed: 10
  };
  
  hearts = [];
  badGuys = [];
  score = 0;
  gameOver = false;
  
  // Clear any existing heart movement interval
  if (heartMoveInterval) {
    clearInterval(heartMoveInterval);
    heartMoveInterval = null;
  }
  
  // Determine number of hearts and enemies based on level
  let heartCount, badGuyCount;
  
  if (currentLevel <= 5) {
    heartCount = currentLevel * 3;
    badGuyCount = currentLevel;
  } else if (currentLevel <= 10) {
    heartCount = 10;
    badGuyCount = 4;
  } else if (currentLevel <= 15) {
    heartCount = 20;
    badGuyCount = 4;
  } else if (currentLevel <= 20) {
    heartCount = 25;
    badGuyCount = 3;
  } else if (currentLevel <= 25) {
    heartCount = 30;
    badGuyCount = 3;
    movingHearts = true;
  } else if (currentLevel <= 30) {
    heartCount = 30;
    badGuyCount = 3;
    movingHearts = true;
  } else if (currentLevel <= 35) {
    heartCount = 40;
    badGuyCount = 2;
    movingHearts = true;
  } else {
    heartCount = 20;
    badGuyCount = 1;
    movingHearts = true;
  }
  
  scoreText.innerText = "0";
  totalHeartsText.innerText = heartCount;
  gameOverText.style.display = "none";
  
  generateHearts(heartCount);
  generateBadGuys(badGuyCount);
  setupTouchControls();
  
  // Start heart movement if needed
  if (movingHearts) {
    heartMoveInterval = setInterval(moveHearts, 500);
  }
  
  gameLoop();
}

// Generate hearts
function generateHearts(count) {
  while (hearts.length < count) {
    let h = {
      x: Math.random() * (canvas.width - 40) + 20,
      y: Math.random() * (canvas.height - 100) + 20,
      size: 15,
      value: 1,
      dx: movingHearts ? (Math.random() * 4 - 2) : 0,
      dy: movingHearts ? (Math.random() * 4 - 2) : 0
    };
    
    if (Math.abs(h.x - player.x) > 50 && Math.abs(h.y - player.y) > 50) {
      if (Math.random() < 0.1 && currentLevel > 3) {
        h.size = 25;
        h.value = 5;
        h.color = "#ffcc00";
      } else {
        h.color = "#ff66a3";
      }
      hearts.push(h);
    }
  }
}

// Move hearts (for higher levels)
function moveHearts() {
  hearts.forEach(h => {
    if (movingHearts) {
      h.x += h.dx;
      h.y += h.dy;
      
      // Bounce off walls
      if (h.x < h.size || h.x > canvas.width - h.size) h.dx *= -1;
      if (h.y < h.size || h.y > canvas.height - h.size) h.dy *= -1;
      
      // Avoid enemies (for level 30+)
      if (currentLevel >= 30) {
        badGuys.forEach(b => {
          const dx = h.x - b.x;
          const dy = h.y - b.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 100) {
            // Move away from enemy
            h.dx = dx / distance * 2;
            h.dy = dy / distance * 2;
          }
        });
      }
    }
  });
}




// Generate bad guys
function generateBadGuys(count) {
  for (let i = 0; i < count; i++) {
    const baseSpeed = 2 + (currentLevel * config.speedIncrease);
    badGuys.push({
      x: Math.random() * (canvas.width - 40) + 20,
      y: Math.random() * (canvas.height - 40) + 20,
      size: 20 + (Math.floor(currentLevel/5) * 5),
      dx: (Math.random() * baseSpeed * 2) - baseSpeed,
      dy: (Math.random() * baseSpeed * 2) - baseSpeed,
      color: ["#99004d", "#660033", "#33001a"][Math.floor(Math.random() * 3)]
    });
  }
}

// Setup touch controls
function setupTouchControls() {
  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
  canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
}

function handleTouchStart(e) {
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const touchX = touch.clientX - rect.left;
  const touchY = touch.clientY - rect.top;
  
  const dx = touchX - player.x;
  const dy = touchY - player.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  if (distance < player.size) {
    isDragging = true;
    touchOffsetX = player.x - touchX;
    touchOffsetY = player.y - touchY;
  }
}

function handleTouchMove(e) {
  if (!isDragging) return;
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  
  player.x = touch.clientX - rect.left + touchOffsetX;
  player.y = touch.clientY - rect.top + touchOffsetY;
  
  keepPlayerInBounds();
}

function handleTouchEnd() {
  isDragging = false;
}

// Create floating hearts in background
function createFloatingHearts() {
  document.querySelectorAll('.heart').forEach(el => el.remove());
  
  for (let i = 0; i < 15; i++) {
    const heart = document.createElement('div');
    heart.className = 'heart';
    heart.innerHTML = '❤️';
    heart.style.left = `${Math.random() * 100}%`;
    heart.style.top = `${Math.random() * 100}%`;
    heart.style.animationDuration = `${3 + Math.random() * 7}s`;
    heart.style.animationDelay = `${Math.random() * 5}s`;
    document.body.appendChild(heart);
  }
}

// Keyboard controls
document.addEventListener("keydown", (e) => {
  if (gameOver) return;
  switch (e.key) {
    case "ArrowLeft": player.x -= player.speed; break;
    case "ArrowRight": player.x += player.speed; break;
    case "ArrowUp": player.y -= player.speed; break;
    case "ArrowDown": player.y += player.speed; break;
  }
  keepPlayerInBounds();
});

// Keep player within canvas bounds
function keepPlayerInBounds() {
  player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
  player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
}

// Draw player
function drawPlayer() {
  ctx.fillStyle = player.color;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
  ctx.beginPath();
  ctx.arc(player.x - player.size/3, player.y - player.size/3, player.size/4, 0, Math.PI * 2);
  ctx.fill();
}

// Draw hearts
function drawHearts() {
  hearts.forEach(h => {
    ctx.fillStyle = h.color || "#ff66a3";
    ctx.beginPath();
    
    const x = h.x;
    const y = h.y;
    const size = h.size;
    
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x, y - size/2, x - size, y - size/2, x - size, y);
    ctx.bezierCurveTo(x - size, y + size/3, x, y + size, x, y + size);
    ctx.bezierCurveTo(x, y + size, x + size, y + size/3, x + size, y);
    ctx.bezierCurveTo(x + size, y - size/2, x, y - size/2, x, y);
    
    ctx.fill();
    
    if (h.value > 1) {
      ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
      ctx.beginPath();
      ctx.arc(x - size/3, y - size/3, size/5, 0, Math.PI * 2);
      ctx.fill();
    }
  });
}

// Draw bad guys
function drawBadGuys() {
  badGuys.forEach(b => {
    ctx.fillStyle = b.color;
    ctx.beginPath();
    
    ctx.moveTo(b.x, b.y - b.size/2);
    ctx.lineTo(b.x + b.size/2, b.y);
    ctx.lineTo(b.x, b.y + b.size/2);
    ctx.lineTo(b.x - b.size/2, b.y);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(b.x - b.size/4, b.y - b.size/6, b.size/8, 0, Math.PI * 2);
    ctx.arc(b.x + b.size/4, b.y - b.size/6, b.size/8, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(b.x - b.size/4 - b.size/16, b.y - b.size/6, b.size/12, 0, Math.PI * 2);
    ctx.arc(b.x + b.size/4 - b.size/16, b.y - b.size/6, b.size/12, 0, Math.PI * 2);
    ctx.fill();
    
    b.x += b.dx;
    b.y += b.dy;
    
    if (b.x < b.size/2 || b.x > canvas.width - b.size/2) b.dx *= -1;
    if (b.y < b.size/2 || b.y > canvas.height - b.size/2) b.dy *= -1;
  });
}

// Check collisions
function checkCollision() {
  hearts.forEach((h, i) => {
    const dx = player.x - h.x;
    const dy = player.y - h.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < player.size + h.size) {
      hearts.splice(i, 1);
      score += h.value;
      scoreText.innerText = score;
      
      const coinsEarned = h.value * 100;
      coins += coinsEarned;
      updateStatsDisplay();
      
      if (h.value > 1) {
        showBonusAlert(`BONUS! +${coinsEarned} coins`, "#ffcc00");
      }
      
      if (hearts.length === 0) {
        levelComplete();
      }
    }
  });
  
  badGuys.forEach(b => {
    const dx = player.x - b.x;
    const dy = player.y - b.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < player.size + b.size/2) {
      endGame();
    }
  });
}

// Show bonus alert
function showBonusAlert(message, color) {
  bonusAlert.textContent = message;
  bonusAlert.style.backgroundColor = color || "#ffcc00";
  bonusAlert.style.display = "block";
  
  bonusAlert.style.animation = "none";
  void bonusAlert.offsetWidth;
  bonusAlert.style.animation = "slideIn 0.5s, fadeOut 0.5s 2.5s forwards";
}

// Level complete
function levelComplete() {
  cancelAnimationFrame(gameLoopId);
  if (heartMoveInterval) {
    clearInterval(heartMoveInterval);
    heartMoveInterval = null;
  }
  
  const levelCoins = config.coinReward * currentLevel;
  coins += levelCoins;
  
  let rewardText = `You earned ${levelCoins} coins!`;
  
  if (config.bonusRewards[currentLevel]) {
    rewardText += `<br><br>Bonus Reward: ${config.bonusRewards[currentLevel]}`;
  }
  
  if (currentLevel % 10 === 0) {
    showFinalWinModal(rewardText);
  } else {
    showWinModal(rewardText);
  }
  
  currentLevel++;
  saveGame();
}

function showWinModal(rewardText) {
  winMessage.textContent = `Level ${currentLevel-1} Complete!`;
  rewardInfo.innerHTML = rewardText;
  winModal.style.display = "flex";
}

function showFinalWinModal(rewardText) {
  finalLevelDisplay.textContent = currentLevel-1;
  finalWinMessage.textContent = `You've completed level ${currentLevel-1}!`;
  finalRewardInfo.innerHTML = rewardText;
  
  const availableCodes = rewardCodes.filter(code => !usedCodes.includes(code));
  if (availableCodes.length > 0) {
    const randomCode = availableCodes[Math.floor(Math.random() * availableCodes.length)];
    rewardCode.textContent = randomCode;
    usedCodes.push(randomCode);
    document.getElementById("rewardCodeContainer").style.display = "block";
  } else {
    rewardText += "<br><br>You've already claimed your reward code for this level!";
    finalRewardInfo.innerHTML = rewardText;
    document.getElementById("rewardCodeContainer").style.display = "none";
  }
  
  finalWinModal.style.display = "flex";
}

// Next level
function nextLevel() {
  winModal.style.display = "none";
  finalWinModal.style.display = "none";
  saveGame();
  initGame();
}

// Try again (same level)
function tryAgain() {
  gameOverText.style.display = "none";
  initGame();
}

// Reset game (only levels, keep coins)
function resetGame() {
  if (confirm("This will reset your level progress but keep your coins. Continue?")) {
    currentLevel = 1;
    playerStats.level = 1;
    saveGame();
    gameOverText.style.display = "none";
    initGame();
  }
}

// End game
function endGame() {
  cancelAnimationFrame(gameLoopId);
  if (heartMoveInterval) {
    clearInterval(heartMoveInterval);
    heartMoveInterval = null;
  }
  gameOver = true;
  gameOverText.style.display = "block";
  saveGame();
}

// Show menu
function showMenu() {
  cancelAnimationFrame(gameLoopId);
  if (heartMoveInterval) {
    clearInterval(heartMoveInterval);
    heartMoveInterval = null;
  }
  saveGame();
  alert("Game paused. Your progress has been saved.");
  initGame();
}

// Toggle fullscreen
function toggleFullscreen() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.error(`Error attempting to enable fullscreen: ${err.message}`);
    });
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }
}

// Game loop
function gameLoop() {
  if (gameOver) return;
  
  ctx.fillStyle = "rgba(255, 240, 245, 0.3)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  drawPlayer();
  drawHearts();
  drawBadGuys();
  checkCollision();
  
  gameLoopId = requestAnimationFrame(gameLoop);
}

// Start the game
window.onload = function() {
  initGame();
};
</script>

</body>
</html>